# 웹

웹(WEB)은 인터넷에서 제공되는 하이퍼텍스트 시스템을 말한다.

> 💡 하이퍼텍스트 (HyperText)   
> 문서안에 다른 문서의 위치정보 등을 포함하여 문서 간의 정보를 서로 연관 지어 참조 할 수 있는 문서

<br>

## 웹 어플리케이션

Application은 크게 Web Application과 Native Application으로 나눌 수 있다.

> Native Application이란 iOS, AOS, Windows와 같은 특정 실행환경에 종속된 어플리케이션을 말하고,
> 
> Web Application은 웹 브라우저를 통해 접근이 가능한 어플리케이션을 말한다.    

<br>

### Native Application

**💡 네이티브 어플리케이션의 장점**

- 웹 어플리케이션보다 빠르다.
- 설치된 기기의 시스템 / 리소스 접근이 용이하다.
- 인터넷이 없어도 사용 가능하다.
- 웹 어플리케이션에 비해 안전하다. (앱스토어 승인)

**💡 네이티브 어플리케이션의 단점**

- 웹 어플리케이션에 비해 개발비가 비싸다.  
  (AOS, iOS 멀티 플랫폼 개발)
- 빠른 업데이트가 어렵다.
- 앱스토어에 승인을 받기가 힘들고, 승인하는데 비용이 발생한다.

<br>

### Web Application

**💡 웹 어플리케이션의 장점**

- 브라우저를 통해 실행되기 떄문에 설치나 다운로드가 필요하지 않다.
- 업데이트 등의 유지관리가 쉽다.
- 네이티브 어플리케이션에 비해 비교적 만들기 간편하다.
- 앱스토어 승인이 필요하지 않다.

**💡 웹 어플리케이션의 단점**

- 인터넷이 없으면 사용할 수 없다.
- 네이티브 어플리케이션에 비해 느리다.
- 앱스토어에서 관리되지 않기 때문에 사용자 접근성이 떨어진다.
- 보안상 위험에 노출되기 쉽다.

<br>

***

<br>

## Web Technology

<br>

### 클라이언트 - 서버 아키텍처

클라이언트는 주로 서비스를 이용하는 쪽 (사용자가 직접 이용)을 말하고,  
리소스와 같은 서비스를 제공하는 쪽을 서버라고 한다.

이렇게 클라이언트와 서버만으로 이루어진 아키텍처를 **2티어 아키텍처**라고 하며,  
서버가 리소스 전달의 역할만 하고, 저장은 데이터베이스에서 담당하는 구조를 **3티어 아키텍처**라고 한다.

<br>

### 웹 어플리케이션 아키텍처

<br>

🔸 Website   

일반적으로 정적인 페이지의 집합체를 말한다.

🔸 Web Application   

동적인 페이지를 포함한 웹사이트
- 데스크탑 어플리케이션처럼 상호작용이 가능하다.
- 정보 검색 등의 특정 기능을 가지고 있다.
- 정보나 자료 등의 콘텐츠 관리 시스템과 함께 작동한다.
- 신뢰성(reliability), 확장성(scalability), 보안성(security), 견고성(robustness) 등의 요소를 고려해야한다.

<br>

🔸 Web Application Architecture  

어플리케이션 구성 요소 간의 
상호 작용을 유지하는 소프트웨어를 구조화 한 것

### 📋 [Web Application](https://nitro04.blogspot.com/2020/01/web-web-application-architecture.html)

<br>

### 웹 어플리케이션의 요청 흐름

1. 브라우저에 URL 입력
   
2. 브라우저는 서버의 주소를 찾기 위해 DNS 서버에 요청을 보낸다.
   
3. IP 주소를 찾으면 해당 주소에 HTTPS 요청을 보낸다.  
   - 이미 방문 기록이 캐시 메모리에 있으면 주소를 캐시 메모리에서 가져온다.
  
4. 웹 서버에 요청 도착
   
5. 웹 서버는 저장소에 요청을 보내 페이지 관련 데이터들을 가져온다.  
   - 정보들은 가져오는 중에 비즈니스 로직이 작용  
   - 비즈니스 로직들은 각 데이터들을 어떻게 다룰지 정해져 있음

6. 로직들을 통해 요청받은 데이터들이 처리되고 브라우저에 응답

7. 브라우저에 응답으로 들어왔을 때, 웹페이지 화면에 출력

<br>

### 웹 어플리케이션의 요소

웹 어플리케이션은 다양한 요소들로 이루어져 있는데, 크게 2가지 영역으로 나눌 수 있다.

- 유저 인터페이스 요소   
  유저 인터페이스(UI)와 유저 경험(UX)과 관련된 요소들   
  > 화면 출력, 로그나, 알림, 시스템 통계, 환경 설정 등 웹 어플리케이션의 기능적인 부분 외적인 요소

- 구조 요소  
  유저와의 상호작용, 제어, 데이터베이스 등에 관련한 요소 등 웹 어플리케이션의 기능과 전체적인 구조 부분을 담당  
  > 웹 브라우저나 클라이언트, 웹 어플리케이션 서버, 데이터베이스 등의 요소

<br>

### 웹 어플리케이션의 3단계 구조

웹 어플리케이션의 구조는 다양한 단계와 계층으로 나뉘지만, 크게 3단계로 나누어 볼 수 있다

<br>

<img src = "https://www.altexsoft.com/media/2019/07/word-image-40.png" width = "90%"/>

▲ _Web application architecture following the three-tier pattern_

<br>

**💡 주 3계층**

- **Presentation Layer**  
  유저가 브라우저 등을 이용해 직접적으로 접촉을 하는 계층   
  Web Server가 이 영역에 포함되며, 유저 인터페이스 요소들을 포함한다.

- **Application Layer (Business Layer, Domain Logic)**  
  유저의 요청을 브라우저로부터 받아서 처리를 하는 계층  
  Application Server가 이 계층에 포함되며, 데이터 접근을 위한 경로를 규격화 하는 등의 과정이 이 계층에 작성이 된다.

- **Persistence layer (Data access layer)**  
  어플리케이선의 데이터 저장소에 접근하여 데이터를 불러 오거나 저장을 담당하는 계층  
  이 단계를 통해 Application Layer의 로직들은 어느 DB에 접근해서 데이터를 회수하고 저장할지 최적화 할 수 있다.

<br>

**💡 기타**

- **Cross-cutting**  
  주로 보안, 통신, 운영 관리등을 위한 요소  

- **Third-party integrations**  
  제 3의 API 서비스를 이용하는 것을 의미  
  OAuth 2.0을 이용한 소셜 로그인, PG사를 이용한 결제 기능 등

<br>

### 웹 어플리케이션의 구현

웹 어플리케이션의 구현 방법은 크게 3가지로 나눌 수 있다.

<br>

**🔸 Single Page Application**

유저의 입력과 요청에 의한 콘텐츠나 정보의 최신화가 페이지를 새로 불러오지 않고 한 페이지에서 이루어지는 형식

SPA는 필수적인 요소만을 요청하고, 이러한 점은 페이지가 새로 고침 되는 것을 방지해 유저 경험을 극대화한다.

주로 AJAX(Asynchronous JavaScript And XMLHttpRequest)를 이용해 구현한다.

<br>

**🔸 Microservice architecture**

작고 가벼운 특정한 한가지 기능에 집중한 웹 어플리케이션을 의미한다.

각 기능 요소들이 상호 의존적으로 설계되지 않는다.  
따라서 기능 개발에 같은 언어를 사용할 필요가 없기 때문에 유연성과 속도, 생산성이 향상된다.

또한 상호 의존적이지 않고 독립적이라는 특징덕에 클라우드, 컨테이너와 잘 어울린다.

<br>

**🔸 Serverless Architectures**

개발자가 웹 어플리케이션의 서버와 기타 기반 기능들에 대해 제3자인 클라우드 서비스 제공자에게 의탁하는 방식

개발자가 기본적인 서버나 기반 기능들에 걱정할 필요 없이 특정기능의 개발에 집중 할 수 있게 한다.

<br>

### 웹 어플리케이션 구현 기술

**🔸 HTML (HyperText Transfer Protocol)**

웹 브라우저상에서 클라이언트와 서버간의 통신을 담당하는 프로토콜

HTTP는 클라이언트에서의 데이터 요청과 서버에서의 요청에 대한 응답을 반복하면서 웹 어플리케이션을 작동시킨다.

<br>

HTTP 요청에는 처리의 종류를 나타내는 메서드 이름과 처리 대상의 이름이 포함되고,  

HTTP 응답에는 요청에 대한 처리 결과를 나타내는 상태 코드와 헤더, 실제 처리결과인 메시지가 포함된다.

<br>

**🔸 Cookie와 Session**

HTTP는 데이터를 요청하고 요청에 대한 응답을 전송하는 무상태성의 프로토콜이다.

단지 무념무상으로 데이터의 전달만 하기 때문에 쿠키와 세션의 기능이 필요하다.

- Cookie  
  유저의 정보를 클라이언트에 보관하고, 다음 접속부터 유저 정보를 클라이언트가 서버로 보내서 유저를 식별하게 한다.  
  쿠키에 담긴 내용으로 웹 어플리케이션에 유저가 설정했던 항목들에 대해 저장을 해서 다음에 이어서 작동하게 도와준다.
  > ex) 쇼핑몰의 장바구니 / 웹 브라우저의 방문 기록

- Session  
  서버에 Session-Id 라는 고유 아이디를 할당해서 유저를 식별한다.  
  단순하고 유출이 되면 안되는 정보는 서버에서 세션 ID와 매칭해서 저장해 관리한다.  
  세션정보는 쿠키에서 관리하고, 실제 매칭되는 값들은 서버 측에서 관리하는 것이 일반적인 방법이다.

<br>

**🔸 사용자 인증**

최근 웹 어플리케이션의 사용자 인증은 점점 개인 정보를 이용한 인증이 강화되고 있다.

사용자 식별용 ID와 PW 뿐만 아니라,  
개인의 신원또한 파악하는 다요소 인증(MFA)이 웹에서의 필수 보안 요소로 자리잡았다.

> 가장 많이 접하는 것은 OAuth 방식의 로그인이다.  
> OAuth 방식은 서비스 자격증명 메커니즘을 다른 믿을만한 제3의 서비스에 위임해 인증하는 방식이다.  
> ex) 카카오톡 인증, PASS 인증 등

<br>

***

<br>

### SSR과 CSR

**🔸 SSR (Server Side Rendering)**

Javascript가 웹 페이지를 브라우저에서 렌더링하는 대신에, 서버에서 렌더링한다.

다시 말해 렌더링이 된 상태로 브라우저에 보낸다.

<br>

💡 주로 사용하는 경우

- SEO(Search Engine Optimization)가 우선 순위인 경우
- 웹 페이지 첫 화면의 빠른 렌더링이 필요한 경우  
  (SSR이 단일 파일 용량이 더 작은 편)
- 웹 페이지가 사용자와 상호작용이 적은 경우  
  (브라우저의 다른 경로로 이동 시 새로 렌더링)

<br>

💡 단점

- 자원 이용이 서버에 집중되므로 유지 비용이 높다.
- 일부 Third-party Javascript Library의 경우 SSR이 불가능할 수 있다.

<br>

> Naver, NewYork Times 등에서 사용

<br>

**🔸 CSR (Client Side Rendering)**

Javascript가 클라이언트에서 페이지를 렌더링한다.

서버가 단일 페이지와 Javascript를 클라이언트에 보내고,  
웹 페이지와 함께 전달된 JavaScript 파일이 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꾼다.

<br>

💡 주로 사용하는 경우

- 반대로 SEO가 우선 순위가 아닌 경우
- 사이트에 많은 상호작용 기능이 있는 경우  
  (서버가 클라이언트에 필요한 데이터만 넘겨주므로 부담이 적음)
- 웹 어플리케이션을 제작하는 경우 더 나은 사용자 경험을 제공  
  (빠른 동적 렌더링 등)

<br>

💡 단점

- 느린 렌더링 속도로 사용자 경험이 안 좋아질 수도 있다.  
  (모든 렌더링의 부하가 클라이언트에 집중되므로 사용자에 따라 경험 상이)
- Search Enginer Bot과 상성이 좋지 않다.

<br>

> agoda와 같은 많은 에약 사이트에서 사용

<br>

### CORS (Cross-Origin Resource Sharing)

CORS는 외부 리소스를 사용하기 위한 SOP의 예외 조항이다.

<br>

> 🔸 동일 출처 정책(Same-Origin Policy, SOP)
> 
> URL의 요소인 Protocol, Host, Port가 동일하지 않으면 다른 출처의 리소스라고 판단하여 접근을 금지한다.

<br>

### 📋 [CORS : MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)

### 📋 [CORS 정리 블로그 1](https://beomy.github.io/tech/browser/cors/)

### 📋 [CORS 정리 블로그 2](https://evan-moon.github.io/2020/05/21/about-cors/)

<br><br>

***

_2022.10.01. Update_