# 인증 / 보안 기초 (Authentication / Security)

<br>

## HTTPS

HTTPS는 Hyper Text Transfer Protocol Secure Soket Layer의 약자로,  
HTTP over SSL(TLS) 또는 HTTP over Secure로 부르기도 한다.

<br>

**💡 HTTPS의 특징**

- 기밀성 (Privacy) : 데이터를 가로챌 수 없음 (조회 불가능)

- 무결성 (Integrity) : 데이터가 조작되지 않음 (수정 불가능)

<br>

HTTPS는 Secure라는 단어에서도 볼 수 있듯이 암호화를 위해 사용하며,  
인증서, CA, 비대칭키 암호화 방식을 사용한다.

<br>

### 🔸 암호화

암호화는 일련의 정보를 임의의 방식을 사용하여 다른 형태로 변환시켜서,  

해당 정보를 소유자 외에는 이해할 수 없도록 알고리즘을 통해 정보를 관리하는 과정을 말한다.

<br>

프로토콜에서 요청이나 응답이 암호화되지 않고 전송된다면, 비밀번호와 같은 중요한 데이터가 유출될 가능성이 있다.

이를 위해 HTTPS에서 클라이언트와 서버가 데이터를 주고받을 때는 대칭키를 사용하고, 대칭키를 주고받는 과정에서 비대칭키 방식으로 주고 받는다.

> **💡 대칭키 & 비대칭키**
>
> 대칭키 방식은 양쪽이 **공통의 비밀키**를 공유하여 데이터를 암호화 및 복호화하는 방식이다.
>
> 비대칭키 방식은 각각 **공개키(public key)와 비밀키(private key)** 를 가지고,  
> 공개키로 암호화한 정보를 개인이 가진 비밀키로 복호화하는 방식 **(암호화)**
> 
> 비밀키로 암호화한 정보를 공개키를 통해 복호화하는 방식 **(인증서 - 전자서명)** 이 있다.

<br>

### 🔸 인증서 (Certificate)

데이터를 제공한 서버가 정말로 데이터를 보낸 서버인지 신원을 인증, 확인하는 용도를 말하며,

HTTPS는 브라우저에서 서버의 응답과 함께 전달된 인증서를 확인할 수 있다.

> 인증서는 비밀키로 암호화하고, 공개키를 통해 복호화하는 방식을 가지고 있다.

<br>

### 🔸 CA (Cretificate Authority)

CA는 인증서를 발급해주는 엄격하게 공인된 기관을 말하며,

서버의 공개키와 정보를 CA의 비밀키로 암호화하여 인증서를 발급한다.

<br>

**💡 HTTPS의 통신 시작을 위한 과정**

**Hand Shake**

1. 서버가 클라이언트에게 CA에서 발급받은 인증서를 보낸다.

2. 클라이언트가 내장된 CA 리스트를 통해 인증서를 확인한다.  
   → 해당 과정에서 실패 시 경고 창이 출력된다.

3. CA의 공개키를 통해 인증서를 복호화한다.

**비밀 키 생성**

4. 클라이언트에서 대칭키를 만들어 서버의 공개키로 암호화하고 서버에 전달한다.

5. 서버는 개인키를 통해 복호화하여 클라이언트의 대칭키를 확인한다.

**상호 키 검증**

6. 서버에서 클라이언트의 대칭키로 데이터를 암호화해서 클라이언트에게 전달한다.

7. 클라이언트는 대칭키로 데이터를 복호화해서 서로의 대칭키가 맞는지 확인한다.

8. HTTPS 연결 성립

<br>

위와 같이 CA를 통해 서버 인증 및 데이터 암호화 과정을 아우른 프로토콜을 **SSL** 또는 **TSL**이라고 한다.

<br>

***

<br>

## Hashing

해싱은 원본 문자열을 알아볼 수 없는 난해한 문자열로 표현하는 과정을 뜻하며, 암호화에 많이 사용된다.

Input → Output이 항상 동일한 순수 함수이며, 해싱된 값(Digest)은 사실상 복호화가 불가능하다.

<br>

해싱에는 3가지 철칙이 존재한다.

1. 모든 값에 대해 해시 값을 계산하는데 오래 걸리지 않아야 한다. (암호화가 빨라야한다.)

2. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 한다.

3. 최대한 다른 해시 값을 피해야하며, 모든 값은 고유한 해시 값을 가져야한다.
   - 극히 낮은 확률로 전혀 다른 문자열인데 똑같은 해시 값을 가지는 경우가 존재

<br>

### 🔸 해싱 알고리즘

대표적인 해싱 알고리즘은 SHA-1, SHA256, SHA512 등이 있으며,  

SHA1은 현재 사용하지 않고, SHA256을 주로 사용한다.

<br>

### 🔸 Salt

암호화해야 하는 값에 '별도의 값'을 추가하여 결과를 변형시키는 것을 말한다.

<br>

특정 알고리즘을 통한 해시는 항상 같은 결과를 리턴하기 때문에,  

원본 값과 해시 값을 대조한 테이블(레인보우 테이블)을 만들어 Decoding하는 경우가 발생할 수 있다.

<br>

따라서 원본 값에 임의의 문자열을 추가하여 해시를 진행하면,  

알고리즘이 노출되더라도 원본 값을 보호할 수 있도록 안전 장치 역할을 해놓을 수 있다.

<br>

**💡 Salt 사용 시 주의 사항**

1. Salt는 유저와 패스워드 별로 유일한 값을 가져야한다.

2. 사용자 게정을 생성할 때와 비밀번호를 변경할 때마다 새로운 Salt를 사용해 해싱해야한다.

3. Salt는 재사용되어서는 안된다.

4. Salt는 DB의 유저 테이블에 함께 저장되어야 한다.

<br>

***

<br>

## Cookie

쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법 중 하나이며,  

주로 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 사용한다.

<br>

쿠키의 목적은 HTTP의 stateless라는 특징을 보완하기 위함에 있다.  

> HTTP 프로토콜에서 상태 정보를 기억시켜 로그인 상태를 유지할 수 있음

<br>

### 🔸 Cookie에서 사용되는 옵션

서버는 쿠키를 이용하여 데이터를 저장하고, 데이터를 다시 불러와 사용할 수 있다.

하지만 데이터들은 아무때나 불러올 수 있는 것이 아닌 특정 조건들이 만족하는 경우에만 불러올 수 있다.

**1. Domain**

도메인은 ```google.com```과 같이 서버에 접속할 수 있는 이름을 뜻하며,  
쿠키 옵션에 도메인 정보가 존재한다면 도메인 옵션과 서버 도메인이 일치해야만 쿠키를 전송한다.

쿠키 옵션에서 도메인은 포트(```:8080```), 서브 도메인 정보(```www.```), 세부 경로를 포함하지 않는다.

<br>

**2. Path**

Path 옵션은 세부 경로를 관리하며, 세부 경로는 서버가 라우팅(경로 설정)할 때 사용하는 경로를 말한다.

Path 옵션은 설정된 path를 전부 만족하는 경우,  
요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있다.

예를 들어 Path가 ```/cafe```로 설정된 경우,  
세부 경로가 ```/cafe/coffee```와 같이 작성되면 Path 옵션을 만족하므로 쿠키를 전송한다.

<br>

**3. MaxAge & Expires**

MaxAge는 앞으로 몇 초동안 쿠키가 유효한지 설정하는 옵션이고,  

Expires는 앞으로 언제까지 유효한지 Date를 지정하는 옵션이다.

> 2가지 속성이 모두 존재할 경우에는 MaxAge 속성이 우세하다.

<br>

클라이언트 시간을 기준으로 시간을 지정하며, 시간을 초과하게 되면 쿠키는 자동으로 소멸된다.

> **💡 세션 쿠키 (Session Cookie) & 영속성 쿠키 (Persistent Cookie)**
>
> 세션 쿠키 : MaxAge, Expire 옵션이 없는 쿠키로, 브라우저가 실행 중일 때 사용하는 임시 쿠키
> → 브라우저를 종료하게 되면 해당 쿠키는 삭제된다.
>
> 영속성 쿠키 : 브라우저의 종료 여부에 상관 없이 옵션에 지정된 유효 시간만큼 사용 가능한 쿠키

<br>

**4. Secure**

Secure 옵션은 쿠키를 전송할 때 사용하는 프로토콜에 따라 쿠키 전송 여부를 결정한다.
 
```true```로 설정되면, 'HTTPS' 프로토콜을 사용하여 통신하는 경우에만 쿠키를 전송할 수 있다.

Default는 ```false```이다.

<br>

**5. HttpOnly**

자바스크립트에서 브라우저의 쿠키에 접근 가능 여부를 결정한다.

```true```로 설정되면, 자바스크립트에서는 쿠키에 접근이 불가능하게 된다.

```false```로 설정되면, 자바스크립트에서 쿠키에 접근이 가능하며 XSS 공격에 취약해진다.

Default는 ```false```이다.

<br>

**6. SameSite**

SameSite에서 추가로 사용 가능한 옵션은 아래와 같다.

- Strict : ```same-site```인 경우에 쿠키를 전송할 수 있다.

- Lax : cross-site 요청라도 safe한 요청에 대해서는 쿠키를 전송할 수 있다.  
  - ```GET``` 메서드 방식  
  - ```<ahref="">```  
  - ```<link rel="prerender">```  

<br>

- None : 항상 쿠키를 보내줄 수 있다. 하지만 쿠키 옵션 중 ```Secure``` 옵션이 필요하다.

<br>

> **💡 origin & site**
> 
> origin : 스킴, 서브도메인, 도메인, 포트로 구성되어 있다.   
> (```https://www.google.com:433```)
>
> site : 도메인만을 포함하는 URL   
> (```google.com```)

<br><br>

위와 같은 옵션들을 지정한 후 **서버 → 클라이언트**로 처음 쿠키를 전송한다면   
헤더에 ```Set-Cookie```라는 프로퍼티에 쿠키를 담아 전송하게 된다.

이후 **클라이언트 → 서버**로 쿠키를 전송할 때, ```Cookie```라는 프로퍼티에 쿠키를 담아 전송하게 된다.

<br>

쿠키는 서버의 부담을 덜어줄 수 있다는 장점이 있지만,  

쿠키 자체는 인증이나 보안의 수단이 아닌 하나의 도구라고 볼 수 있다.

<br>

🚨 또한 쿠키는 오랜시간 유지될 수 있고, 자바스크립트를 통해 쿠키에 접근할 수 있기 때문에 

&emsp; **쿠키에 민감한 정보를 담는 것은 위험하다.**

<br>

***

<br>

## Session

세션은 서버가 해당 서버로 접근하는 클라이언트(사용자)를 식별하는 방법이다.

주로 SSR(Server Side Rendering) 방식에서 사용하는 인증 방식이며, 아래와 같은 특징이 있다.

- 접속 상태를 서버가 가짐(stateful)

- 접속 상태와 권한 부여를 위해 세션 아이디를 쿠키로 전송

<br>

### 🔸 세션 기반 인증 (Session-based Authentication)

<br>

<img src = "https://velog.velcdn.com/images%2Fjun7867%2Fpost%2Fcc01ef5e-b17f-45f9-ad28-cd5abb637f43%2Fimage.png" width = "500">

<br>

1. 클라이언트가 서버로 접속을 시도한다.

   - 해당 유저가 인증에 성공했다면, 인증에 따라 리소스의 접근 권한이 달라져야 한다.

<br>

2. 서버는 접근한 클라이언트의 Cookie를 확인해 Session ID가 존재하는지 확인한다.

   -  Session ID가 없다면 생성해 Cookie에 담아서 응답한다.

<br>

3. 서버로부터 발행된 Session ID는 해당 서버와 클아이언트 메모리에 저장된다.

   - 이때 사용되는 Cookie 타입은 세션 종료 시 같이 소멸되는 Memory Cookie이다.

<br>

4. 클라이언트 접속 종료 시, 서버에 저장된 Session ID는 소멸된다.

   - 서버는 세션 정보를 삭제하고, 클라이언트에서는 쿠키를 갱신해야한다.

   - 서버에서 클라이언트에 쿠키를 전송할 때 Session ID의 키 값을 무효한 값으로 갱신

<br>

> 서버는 사용자가 인증에 성공했음을 알고 있어야 한다.  
> 클라이언트는 인증 성공을 증명할 수단을 갖고 있어야 한다.
>
> 사용자가 인증에 성공한 상태를 **세션**이라고 한다.  
> 
> 세션은 주로 In-memory 또는 세션 스토어 (redis와 같이 트랜잭션이 빠른 DB)에 저장된다.


<br>

***

<br>

## 웹 보안 공격

<br>

### 🔸 SQL Injection

클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격할 수 있는 공격방식

<br>

```sql
SELECT * 
FROM users
WHERE auth='admin'
AND id='input';
```

사용자가 Input을 통해 입력하는 값은 위와 같은 쿼리문을 통해 데이터베이스에 접근한다.

<br>

만약 여기서 ```' OR '1' = '1```을 입력해서 보낸다면

```sql
SELECT * 
FROM users
WHERE auth='admin'
AND id='' OR '1'='1';
```

위와 같은 쿼리문이 작성될 것이고, 해당 값은 ```TRUE```가 되어 로그인에 성공할 것이다.

<br>

### **💡 대응 방안**

<br>

**1. 입력값 검증**

정규 표현식과 같은 방식을 통해 해당 입력값을 검증할 수 있다.

<br>

**2. Prepared Statement 구문 사용**

Prepared Statement 구문을 사용하면 사용자 입력이 SQL문으로부터 분리되어 공격을 방어할 수 있다.

입력값 전달 이전에 DB가 미리 컴파일하여 SQL을 실행시키지 않고 대기하며,  

입력 값을 SQL문이 아닌 단순 텍스트로 인식하게 된다.

<br>

**3. Error Message 노출 금지**

DB의 에러 메세지를 통해 테이블이나 칼럼 등의 정보를 얻을 수 있으므로,  

에러 메세지를 노출하지 않도록 별도의 에러 핸들링이 필요하다.

<br>

**4. ORM을 사용**

JPA와 같은 Prameter Value Binding 방식은 SQL 쿼리문에 직접 접근하지 않으므로,

SQL Injection 공격을 방어할 수 있다.  

다만, ```@Query``` 어노테이션을 사용하거나, JDBC와 mybatis의 ```${}``` 문법은 인젝션 공격을 당할 수 있다.

<br>

### 🔸 CSRF (Cross-Site Request Forgery, 사이트 간 요청 위조)

cross-site에서 유저가 보내는 요청(Request)을 조작(Forgery)하는 공격을 말한다.

해당 공격은 해커가 직접 데이터에 직접 접근할 수 없다.

<br>

**💡 CSRF 공격을 위한 조건**

- 쿠키를 사용한 로그인 : 유저가 로그인 했을 때, 쿠키를 통해 어떤 유저인지 알 수 있어야함

- 예측할 수 있는 요청 /parameter를 가지고 있어야 함 :  request에 해커가 모를 수 있는 정보가 담겨있으면 안됨

<br>

### **💡 대응 방안**

<br>

**1. CSRF 토큰 사용**

서버 측에서 CSRF 공격에 보호하기 위한 문자열을 유저의 브라우저와 웹 앱에만 제공

<br>

**2. Same-site Cookie 사용**

같은 도메인에서만 세션 / 쿠키를 사용할 수 있도록 한다.

<br>

### 🔸 XSS (Cross-Site Scripting, 사이트 간 스크립팅)

공격하려는 사이트에 스크립트를 넣는 기법을 말한다. 

공격에 성공하면 사이트에 접속한 사용자는 삽입된 코드를 실행하게 되며,  
보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등의 민감한 정보를 탈취한다.

<br>

### **💡 대응 방안**

XSS 공격은 미리 방지하기 어려우며,  
특히 악성 프로그램은 사용자의 개인 장치가 아닌 사용자가 방문하는 웹사이트를 대상으로 하기에 공격에 노출되기 쉽다.

다만, Chrome, Safari 등 대부분의 보안 브라우저에는 반사형 XSS를 탐지하고 차단하는 데 도움이 되는 보안 기능이 내장되어 있다.

<br>

**1. Script 문자 필터링**

XSS 공격은 입력값에 대한 검증이 제대로 이루어지지 않아 발생하는 취약점이다.

따라서 사용자의 모든 입력 값에 대하여 서버 측에서 필터링을 해주어야 한다.

<br>

**2. XSS 공격에 대한 이해**

URL을 계속 확인하는 습관이나, 전문 기술 지식을 보유하고 있다면 방문하는 모든 웹페이지의 코드를 조사하고 악성 스크립트가 있는지 확인하는 것이 좋다.

<br><br>

***

_2022.11.23. Modified_

_2022.11.18. Update_